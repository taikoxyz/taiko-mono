//! Swarm and behaviour event handling for the network driver.
//!
//! This module implements the core poll loop and event dispatch logic, handling
//! incoming commands, swarm events (connections, disconnections), and behaviour
//! events (gossip, req/resp).

use std::task::{Context, Poll};

use libp2p::swarm::SwarmEvent;
use preconfirmation_types::{
    GetCommitmentsByNumberRequest, GetHeadRequest, GetRawTxListRequest,
    MAX_COMMITMENTS_PER_RESPONSE, validate_commitments_request,
};

use super::*;

impl NetworkDriver {
    /// Send an outbound req/resp request after selecting an eligible peer.
    fn send_outbound_request<F>(
        &mut self,
        peer: Option<PeerId>,
        kind: ReqRespKind,
        responder: Option<super::reqresp::ReqRespResponder>,
        send: F,
    ) where
        F: FnOnce(&mut Self, PeerId) -> libp2p::request_response::OutboundRequestId,
    {
        if let Some(target) = self.choose_peer(peer) {
            let req_handle = send(self, target);
            self.track_outbound_request(kind, req_handle, responder);
        } else {
            self.handle_no_peer_available(kind, responder);
        }
    }

    /// Polls the swarm for events and processes commands.
    pub fn poll(&mut self, cx: &mut Context<'_>) -> Poll<()> {
        while let Poll::Ready(Some(cmd)) = self.commands_rx.poll_recv(cx) {
            self.handle_command(cmd);
        }

        if let Some(rx) = self.discovery_rx.as_mut() {
            let mut drained = Vec::new();
            while let Poll::Ready(Some(addr)) = rx.poll_recv(cx) {
                drained.push(addr);
            }

            for addr in drained {
                self.handle_discovered_addr(addr);
            }
        }

        match self.swarm.poll_next_unpin(cx) {
            Poll::Ready(Some(event)) => {
                self.handle_swarm_event(event, cx);
                Poll::Ready(())
            }
            Poll::Ready(None) => Poll::Ready(()),
            Poll::Pending => Poll::Pending,
        }
    }

    /// Handles `SwarmEvent`s emitted by the libp2p swarm.
    fn handle_swarm_event(&mut self, event: SwarmEvent<NetBehaviourEvent>, cx: &mut Context<'_>) {
        match event {
            SwarmEvent::Behaviour(ev) => self.handle_behaviour_event(ev, cx),
            SwarmEvent::NewListenAddr { address, .. } => {
                let _ = self.events_tx.try_send(NetworkEvent::NewListenAddr(address));
            }
            SwarmEvent::ConnectionEstablished { peer_id, .. } => {
                self.connected_peers += 1;
                metrics::gauge!("p2p_connected_peers").set(self.connected_peers as f64);
                if self.reputation.is_banned(&peer_id) {
                    let _ = self.swarm.disconnect_peer_id(peer_id);
                }
                let _ = self.events_tx.try_send(NetworkEvent::PeerConnected(peer_id));
            }
            SwarmEvent::ConnectionClosed { peer_id, .. } => {
                self.connected_peers -= 1;
                metrics::gauge!("p2p_connected_peers").set(self.connected_peers.max(0) as f64);
                let _ = self.events_tx.try_send(NetworkEvent::PeerDisconnected(peer_id));
                self.emit_error(
                    NetworkErrorKind::Disconnect,
                    format!("peer {peer_id} connection closed"),
                );
            }
            SwarmEvent::IncomingConnectionError { error, .. } => {
                let reason =
                    if error.to_string().contains("Exceeded") { "limit_exceeded" } else { "other" };
                metrics::counter!("p2p_conn_error", "direction" => "in", "reason" => reason)
                    .increment(1);
                if reason == "limit_exceeded" {
                    metrics::counter!("p2p_conn_rejected_total", "direction" => "in", "reason" => reason)
                        .increment(1);
                }
                self.emit_error(
                    NetworkErrorKind::DialFailed,
                    format!("incoming connection error: {error}"),
                );
            }
            SwarmEvent::OutgoingConnectionError { error, .. } => {
                let reason =
                    if error.to_string().contains("Exceeded") { "limit_exceeded" } else { "other" };
                metrics::counter!("p2p_conn_error", "direction" => "out", "reason" => reason)
                    .increment(1);
                if reason == "limit_exceeded" {
                    metrics::counter!("p2p_dial_throttled_total", "reason" => reason).increment(1);
                }
                self.emit_error(
                    NetworkErrorKind::DialFailed,
                    format!("outgoing connection error: {error}"),
                );
            }
            _ => {}
        }
    }

    /// Handles `NetBehaviourEvent`s generated by the combined network behaviour.
    fn handle_behaviour_event(&mut self, ev: NetBehaviourEvent, cx: &mut Context<'_>) {
        match ev {
            NetBehaviourEvent::Gossipsub(ev) => self.handle_gossipsub_event(ev),
            NetBehaviourEvent::CommitmentsRr(ev) => self.handle_commitments_rr_event(ev, cx),
            NetBehaviourEvent::RawTxlistsRr(ev) => self.handle_raw_txlists_rr_event(ev, cx),
            NetBehaviourEvent::HeadRr(ev) => self.handle_head_rr_event(ev, cx),
            _ => {}
        }
    }

    /// Handles incoming `NetworkCommand`s from the service layer.
    fn handle_command(&mut self, cmd: NetworkCommand) {
        match cmd {
            NetworkCommand::PublishCommitment(msg) => {
                let topic = self.topics.0.clone();
                if let Err(err) = self.publish_gossip(&topic, msg) {
                    metrics::counter!("p2p_gossip_publish_error", "kind" => "commitment")
                        .increment(1);
                    self.emit_error(
                        NetworkErrorKind::PublishFailure,
                        format!("gossip commitment: {err}"),
                    );
                }
            }
            NetworkCommand::PublishRawTxList(msg) => {
                let topic = self.topics.1.clone();
                if let Err(err) = self.publish_gossip(&topic, msg) {
                    metrics::counter!("p2p_gossip_publish_error", "kind" => "raw_txlists")
                        .increment(1);
                    self.emit_error(
                        NetworkErrorKind::PublishFailure,
                        format!("gossip raw-txlist: {err}"),
                    );
                }
            }
            NetworkCommand::RequestCommitments { respond_to, start_block, max_count, peer } => {
                let req =
                    GetCommitmentsByNumberRequest { start_block_number: start_block, max_count };
                if validate_commitments_request(&req, MAX_COMMITMENTS_PER_RESPONSE as u32).is_ok() {
                    self.send_outbound_request(
                        peer,
                        ReqRespKind::Commitments,
                        respond_to.map(super::reqresp::ReqRespResponder::Commitments),
                        move |driver, target| {
                            driver.swarm.behaviour_mut().commitments_rr.send_request(&target, req)
                        },
                    );
                } else {
                    metrics::counter!("p2p_reqresp_error", "kind" => "commitments", "reason" => "validation").increment(1);
                    let err = NetworkError::new(
                        NetworkErrorKind::ReqRespValidation,
                        format!("invalid commitments request: max_count {max_count} exceeds cap"),
                    );
                    let _ = self.events_tx.try_send(NetworkEvent::Error(err));
                }
            }
            NetworkCommand::RequestRawTxList { respond_to, raw_tx_list_hash, peer } => {
                let req = GetRawTxListRequest { raw_tx_list_hash };
                self.send_outbound_request(
                    peer,
                    ReqRespKind::RawTxList,
                    respond_to.map(super::reqresp::ReqRespResponder::RawTxList),
                    move |driver, target| {
                        driver.swarm.behaviour_mut().raw_txlists_rr.send_request(&target, req)
                    },
                );
            }
            NetworkCommand::RequestHead { respond_to, peer } => {
                let req = GetHeadRequest::default();
                self.send_outbound_request(
                    peer,
                    ReqRespKind::Head,
                    respond_to.map(super::reqresp::ReqRespResponder::Head),
                    move |driver, target| {
                        driver.swarm.behaviour_mut().head_rr.send_request(&target, req)
                    },
                );
            }
            NetworkCommand::UpdateHead { head } => {
                self.head = head;
            }
            NetworkCommand::Dial { addr, respond_to } => {
                let result = self.swarm.dial(addr.clone()).map_err(|e| e.to_string());
                if let Some(tx) = respond_to {
                    let _ = tx.send(result);
                }
            }
            NetworkCommand::GetListeningAddrs { respond_to } => {
                let addrs: Vec<_> = self.swarm.listeners().cloned().collect();
                let _ = respond_to.send(addrs);
            }
        }
    }
}
