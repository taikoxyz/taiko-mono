# P2P Client Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build `crates/p2p`, an opinionated client around `preconfirmation-p2p` that sidecars use to publish/subscribe preconfirmation gossip, run catch-up (head + commitments + raw txlists), manage storage/dedup/backpressure, expose metrics, and track head after contract sync.

**Architecture:** `P2pClient` wraps `preconfirmation_p2p_service::P2pService`, layering validation, storage, and orchestration (startup catch-up → live gossip). Modules for config, errors, types/events, storage, resolver, validation, catch-up, handlers, metrics, and tests. No feature flags; defaults mirror Kona/reth presets. Rust async with Tokio, structured tracing, and metrics.

**Tech Stack:** Rust 1.88, tokio, futures, thiserror, tracing, metrics, preconfirmation-p2p (net + service + types), ssf/ssz helpers already in `preconfirmation_types`, optional `lru` for caches.

### Task 1: Workspace wiring & scaffold ✅
**Files:**
- Create: `crates/p2p/Cargo.toml`
- Create: `crates/p2p/src/lib.rs`
- Modify: workspace `Cargo.toml` members

**Steps:**
1. Add `crates/p2p` to `[workspace].members` in root `Cargo.toml`.
2. Write `crates/p2p/Cargo.toml` with deps: `preconfirmation-p2p = { path = "../preconfirmation-p2p/crates/service" }`, `preconfirmation-types = { path = "../preconfirmation-p2p/crates/types" }`, `tokio`, `futures`, `thiserror`, `tracing`, `metrics`, `lru` (or `moka` if already in repo), `serde` (derive), `anyhow` (tests only), `parking_lot` (optional for caches), `uuid`? avoid unless needed.
3. Scaffold `src/lib.rs` exporting modules (`config`, `error`, `types`, `storage`, `resolver`, `validation`, `client`, `catchup`, `handlers`, `metrics`, `test_utils`). Run `cargo check -p p2p` (expect PASS once stubs compile).

### Task 2: Config wrapper ✅ (fields wired into runtime)
**Files:** `crates/p2p/src/config.rs`, update `lib.rs`

**Steps:**
1. Define `P2pClientConfig` with fields: `network: NetworkConfig`, `chain_id: u64`, channel sizes (cmd/event), cache limits (commitments, txlists), timeouts (req/resp, bootstrap), `max_commitments_per_page`, `enable_metrics`, `gossipsub_validation_soft_fail` flag, `executor_slot_grace` (for submissionWindowEnd drift), `disk_storage` toggle placeholder.
2. Provide `Default` mirroring Kona/reth defaults (mesh, scoring) via `NetworkConfig::default()`; expose builder-style setters.
3. Add helper to derive topic/protocol IDs from `chain_id` using `preconfirmation_types` helpers.

### Task 3: Error model ✅
**Files:** `crates/p2p/src/error.rs`

**Steps:**
1. Create `P2pClientError` (thiserror) variants: `Validation`, `Network(NetworkError)`, `Storage`, `Timeout`, `Backpressure`, `Decode`, `Shutdown`, `MissingPeer`, `MissingData`, `Join`.
2. Implement conversions from `NetworkError`, `broadcast::error`, `mpsc::error`, `tokio::time::error::Elapsed`.
3. Add `Result<T> = std::result::Result<T, P2pClientError>` type alias.

### Task 4: Types façade ✅
**Files:** `crates/p2p/src/types.rs`

**Steps:**
1. Re-export `preconfirmation_types::{SignedCommitment, RawTxListGossip, GetCommitmentsByNumberRequest/Response, GetRawTxListRequest/Response, PreconfHead, Preconfirmation, PreconfCommitment, Bytes32, Uint256}`.
2. Define client enums/structs: `SdkEvent` (wraps gossip/reqresp/inbound/head sync progress), `SdkCommand` (high-level publish/request intent), `HeadSyncStatus` (Idle/Syncing/Live with heights), `PeerInfo` (peer id + score snapshot).
3. Add lightweight `MessageId` newtype for dedupe keyed by payload hash + topic.

### Task 5: Storage abstraction ✅ (partial)
Completed: core `SdkStorage` CRUD; in-memory impl; `PreconfStorage` bridge for inbound serving; tests for ordering.
Deferred: cache byte caps, pending/children/prune helpers, message-id tracking.

### Task 6: Lookahead resolver bridge ✅ (minimal alias/noop)

### Task 7: Validation layer ✅
**Files:** `crates/p2p/src/validation.rs`

**Steps:**
1. Implement `validate_signed_commitment` applying spec §4-§5 (signature over domain, slasher match, submissionWindowEnd, parent linkage, block params, chain id). Accept `Lookahead` handle for slot signer check; allow soft-buffer when schedule missing.
2. Implement `validate_raw_txlist_gossip` per spec §3.4 + size caps; ensure `keccak(txlist) == rawTxListHash` when available; cap bytes.
3. Return `ValidationOutcome { valid, penalize_peer, reason }` to feed scoring; integrate with metrics.

### Task 8: Backpressure & dedupe ✅ (bounded fanout + storage eviction)
Current: bounded command/event channels with `Backpressure` surfaced; gossip dedupe via LRU; req/resp latency timers; storage caches evict by count/bytes. Pending: message-id keyed dedupe per topic if needed.
**Files:** `crates/p2p/src/client.rs`, `crates/p2p/src/storage/memory.rs`

**Steps:**
1. Introduce bounded mpsc for commands to driver and bounded event queue; on saturation return `P2pClientError::Backpressure` and emit error event (DONE).
2. Maintain per-topic dedupe cache keyed by payload hash; LRU eviction keeps memory bounded (DONE). Optional message-id layer still open.

### Task 9: Client core orchestration ✅ (baseline)
Notes: wraps service with shared storage; helpers for publish/request; still no `run_with_handler` convenience loop.
**Files:** `crates/p2p/src/client.rs`, update `lib.rs`

**Steps:**
1. Implement `P2pClient::start(cfg, storage, lookahead)` creating `P2pService::start_with_lookahead_and_storage`; spawn background task piping `NetworkEvent` → internal handler; expose handles for shutdown.
2. Provide async helpers: `publish_commitment`, `publish_raw_txlist`, `request_commitments`, `request_raw_txlist`, `request_head`, `update_head`, `subscribe`, `next_event`, `shutdown`. Map errors to `P2pClientError` and wrap validation before publish.
3. Expose `run_with_handler` taking a callback/trait to consume `SdkEvent` for sidecar components.

### Task 10: Catch-up pipeline ✅ (current scope)
Completed: head discovery, commitments paging, raw-txlist requests, retry/backoff with Tick, status events, and head-sync metrics hooks.
Deferred (future): finer-grained backoff tuning, restart-on-disconnect hooks, L2-sync gating, and deeper raw-txlist pagination policies.
**Files:** `crates/p2p/src/catchup.rs`

**Steps:**
1. Implement `run_bootstrap(storage_head, chain_tip)` that: requests `get_head`; if peer head > local, page `get_commitments_by_number` (respect `max_commitments_per_page`), validate and store; enqueue missing txlist hashes; fetch via `get_raw_txlist` with size/timeouts.
2. Emit `SdkEvent::HeadSyncStatus` updates; transition to Live once caught up; surface timeout/backoff policy.
3. Ensure bootstrap runs after sidecar signals L2 execution sync complete; allow restart on disconnect.

### Task 11: Gossip & req/resp handlers ✅ (inbound served via shared storage; mapping/validation done in client). Deferred: scoring hooks/rate limits.
**Files:** `crates/p2p/src/handlers.rs`

**Steps:**
1. Map `NetworkEvent` → internal handling: validate, dedupe, persist to storage, emit `SdkEvent` to subscribers. Apply scoring hints (penalize on invalid, reward on accept) via driver hooks if exposed.
2. Handle inbound requests using storage (`GetCommitmentsByNumberResponse`, `GetRawTxListResponse`, `PreconfHead`) with caps and rate limits; log oversized/invalid.

### Task 12: Publishing helpers ✅
**Files:** `crates/p2p/src/client.rs` (or `publish.rs` helper)

**Steps:**
1. Wrap publish calls with local validation (so sidecar can fail fast); tag messages with message id for dedupe/self-ignore.
2. Provide convenience to publish commitment + optional txlist atomically (txlist first then commitment) to follow spec §6.1 ordering guidance.

### Task 13: Metrics & logging ✅ (baseline)
Completed: gossip counters, validation outcomes, cache hits, req/resp latency, head sync gauges, head-sync status callbacks.
Deferred (future): req/resp counters per outcome, peer score gauges, richer tracing spans.
**Files:** `crates/p2p/src/metrics.rs`, hook in client/handlers/catchup

**Steps:**
1. Define counters: `p2p_gossip_received_total{topic,outcome}`, `p2p_gossip_publish_total{topic,outcome}`, `p2p_reqresp_requests_total{protocol,outcome}`, `p2p_reqresp_latency_seconds`, `p2p_cache_hits_total{kind}`, `p2p_validation_failures_total{reason}`, `p2p_peer_score_gauge`.
2. Add tracing spans on per-message handling with peer/topic/hash; include dedupe and validation outcomes.

### Task 14: Unit tests ✅ (baseline)
Completed: validation edge cases, storage ordering, client mapping, catch-up retries/txlist requests, publish helpers, latency/backpressure, eviction caps, integration smoke, doctests.
Deferred (future): more exhaustive retry/backoff fault injection and broader validation tables.
**Files:** `crates/p2p/src/{validation.rs,handlers.rs,cachup.rs,storage/memory.rs}` (inline `#[cfg(test)]` or `tests/`)

**Steps:**
1. Table-driven tests for validation (good sig, bad signer, wrong parent hash, oversize txlist, EOP handling).
2. Tests for dedupe/backpressure (bounded channels drop/reject), storage cache eviction obeying limits.
3. Catch-up tests with mocked `NetworkEvent` stream ensuring ordering + retry/backoff.

### Task 15: Integration smoke ✅
Notes: Implemented a minimal single-node smoke test driving synthetic gossip/reqresp through `P2pClient::process_event_test`; exercises publish + validation + storage.
**Files:** `crates/p2p/tests/integration_smoke.rs`

**Steps:**
1. Drive `P2pClient` with in-memory storage and synthetic gossip/reqresp; assert publish helpers store data (DONE).
2. Run `cargo test -p p2p -- --nocapture integration_smoke` (DONE).

### Task 16: Docs & examples ✅ (crate-level quick start)
Added a crate-level rustdoc quick start covering start → subscribe → publish txlist+commitment. README still optional.
**Files:** `crates/p2p/src/lib.rs`

**Steps:**
1. Document lifecycle and quick usage path (DONE). Metrics/lifecycle deep-dive can follow if needed.

### Task 17: Verification ✅ (current run)
Local `cargo check -p p2p` and `cargo test -p p2p` (including integration_smoke + doctests) are green. Clippy/fmt still TODO per workflow.
**Files:** N/A

**Steps:**
1. Run `cargo check -p p2p` (DONE).
2. Run `cargo test -p p2p` including integration_smoke + doctests (DONE).
3. Plan to run `just fmt`/`just clippy` before PR (PENDING).

### Task 18: Storage message IDs ✅
Added message-id abstraction (topic + hash) with LRU+TTL cache in `SdkStorage`; `InMemoryStorage` now records/evicts message IDs and exposes record/check API. Included message-id cache tests and TTL expiry coverage.
**Files:** `crates/p2p/src/storage/mod.rs`, `crates/p2p/src/types.rs`

**Steps:**
1. Introduce `MessageId`/`MessageTopic` and hash conversion helpers for dedupe.
2. Extend `SdkStorage` with `record_message_id`, backed by LRU+TTL in `InMemoryStorage` with configurable caps/TTL.
3. Add unit tests for message-id dedupe and expiry.

### Task 19: Client dedupe & self-ignore ✅
Client now records outbound message IDs and drops inbound duplicates early; self-publish helpers mark IDs to ignore echo. Added tests for duplicate commitment/raw txlist suppression.
**Files:** `crates/p2p/src/client.rs`, `crates/p2p/src/types.rs`

**Steps:**
1. Wire storage message-id cache into gossip handling and publish helpers.
2. Remove per-topic LRU fields in client in favor of storage-backed dedupe.
3. Add client unit tests ensuring duplicate gossip is filtered.

### Task 20: Catch-up resilience & backoff ✅
Catch-up state machine now supports configurable jittered exponential backoff, retry budgets, sequential raw-txlist queueing, and restart-on-disconnect handling.
**Files:** `crates/p2p/src/catchup.rs`, `crates/p2p/src/config.rs`

**Steps:**
1. Add backoff config (min/max/budget) and jittered retry logic for head/commitment/txlist fetches.
2. Queue raw txlists, retry with budgeted backoff, and advance on responses.
3. Restart catch-up on peer disconnect during sync.
4. Expand catch-up tests for queueing and retry behavior.

### Task 21: Inbound protections & rate limits ✅
Per-peer req/resp rate limiter added for inbound head/commitments/txlist requests with metric outcomes and error surfacing.
**Files:** `crates/p2p/src/client.rs`, `crates/p2p/src/config.rs`

**Steps:**
1. Introduce sliding-window rate limiter with configurable limit/window.
2. Apply limits to inbound req/resp events; record outcomes.
3. Cover limiter behavior with unit test.

### Task 22: Metrics & tracing ✅ (baseline)
Expanded req/resp outcome counters and peer score gauge placeholder; latencies still recorded. Tracing hooks remain minimal and can be extended later.
**Files:** `crates/p2p/src/metrics.rs`, hook sites in `client.rs`

**Steps:**
1. Add `REQRESP_OUTCOMES_TOTAL` counter and peer score gauge helper.
2. Record outcomes for successes, rate limits, and raw handling paths.

### Task 23: Broader tests ✅
Added message-id dedupe tests, rate limiter test, catch-up backoff/queue tests, and adjusted integration smoke to reflect duplicate filtering.
**Files:** `crates/p2p/src/{client.rs,catchup.rs,storage/mod.rs}`, `crates/p2p/tests/integration_smoke.rs`

**Steps:**
1. Table-style coverage for dedupe and rate limit behaviors.
2. Catch-up retry/queue scenarios with budgeted backoff.
3. Integration smoke updated for new dedupe semantics.

### Task 24: Plan update ✅
Documented completion of tasks 18–23, ran `just fmt` and `cargo test -p p2p` to validate changes. Clippy remains to be run before PR if desired.
**Files:** `docs/plans/2025-12-12-p2p-sdk.md`

**Steps:**
1. Summarize newly completed tasks in plan doc.
2. Ensure formatting/tests run; note pending clippy as follow-up.
