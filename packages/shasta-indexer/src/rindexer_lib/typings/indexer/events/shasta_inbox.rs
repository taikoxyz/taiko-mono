#![allow(
    non_camel_case_types,
    clippy::enum_variant_names,
    clippy::too_many_arguments,
    clippy::upper_case_acronyms,
    clippy::type_complexity,
    dead_code
)]
use super::super::super::super::typings::database::get_or_init_postgres_client;
use super::super::super::super::typings::networks::get_provider_cache_for_network;
/// THIS IS A GENERATED FILE. DO NOT MODIFY MANUALLY.
///
/// This file was auto generated by rindexer - https://github.com/joshstevens19/rindexer.
/// Any manual changes to this file will be overwritten.
use super::shasta_inbox_abi_gen::RindexerShastaInboxGen::{
    self, RindexerShastaInboxGenEvents, RindexerShastaInboxGenInstance,
};
use alloy::network::AnyNetwork;
use alloy::primitives::{Address, Bytes, B256};
use alloy::sol_types::{SolEvent, SolEventInterface, SolType};
use rindexer::{
    async_trait,
    blockclock::BlockClock,
    event::{
        callback_registry::{
            EventCallbackRegistry, EventCallbackRegistryInformation, EventCallbackResult,
            EventResult, HasTxInformation, TxInformation,
        },
        contract_setup::{ContractInformation, NetworkContract},
    },
    generate_random_id,
    manifest::{
        contract::{Contract, ContractDetails},
        yaml::read_manifest,
    },
    provider::{JsonRpcCachedProvider, RindexerProvider},
    FutureExt, PostgresClient,
};
use std::collections::HashMap;
use std::error::Error;
use std::future::Future;
use std::path::{Path, PathBuf};
use std::pin::Pin;
use std::{any::Any, sync::Arc};

pub type AdminChangedData = RindexerShastaInboxGen::AdminChanged;

#[derive(Debug, Clone)]
pub struct AdminChangedResult {
    pub event_data: AdminChangedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for AdminChangedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type BeaconUpgradedData = RindexerShastaInboxGen::BeaconUpgraded;

#[derive(Debug, Clone)]
pub struct BeaconUpgradedResult {
    pub event_data: BeaconUpgradedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for BeaconUpgradedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type BondInstructedData = RindexerShastaInboxGen::BondInstructed;

#[derive(Debug, Clone)]
pub struct BondInstructedResult {
    pub event_data: BondInstructedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for BondInstructedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type BondWithdrawnData = RindexerShastaInboxGen::BondWithdrawn;

#[derive(Debug, Clone)]
pub struct BondWithdrawnResult {
    pub event_data: BondWithdrawnData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for BondWithdrawnResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type InitializedData = RindexerShastaInboxGen::Initialized;

#[derive(Debug, Clone)]
pub struct InitializedResult {
    pub event_data: InitializedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for InitializedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type OwnershipTransferStartedData = RindexerShastaInboxGen::OwnershipTransferStarted;

#[derive(Debug, Clone)]
pub struct OwnershipTransferStartedResult {
    pub event_data: OwnershipTransferStartedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for OwnershipTransferStartedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type OwnershipTransferredData = RindexerShastaInboxGen::OwnershipTransferred;

#[derive(Debug, Clone)]
pub struct OwnershipTransferredResult {
    pub event_data: OwnershipTransferredData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for OwnershipTransferredResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type PausedData = RindexerShastaInboxGen::Paused;

#[derive(Debug, Clone)]
pub struct PausedResult {
    pub event_data: PausedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for PausedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type ProposedData = RindexerShastaInboxGen::Proposed;

#[derive(Debug, Clone)]
pub struct ProposedResult {
    pub event_data: ProposedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for ProposedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type ProvedData = RindexerShastaInboxGen::Proved;

#[derive(Debug, Clone)]
pub struct ProvedResult {
    pub event_data: ProvedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for ProvedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type UnpausedData = RindexerShastaInboxGen::Unpaused;

#[derive(Debug, Clone)]
pub struct UnpausedResult {
    pub event_data: UnpausedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for UnpausedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type UpgradedData = RindexerShastaInboxGen::Upgraded;

#[derive(Debug, Clone)]
pub struct UpgradedResult {
    pub event_data: UpgradedData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for UpgradedResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

#[async_trait]
trait EventCallback {
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()>;
}

pub struct EventContext<TExtensions>
where
    TExtensions: Send + Sync,
{
    pub database: Arc<PostgresClient>,

    pub extensions: Arc<TExtensions>,
}

// didn't want to use option or none made harder DX
// so a blank struct makes interface nice
pub struct NoExtensions {}
pub fn no_extensions() -> NoExtensions {
    NoExtensions {}
}

pub fn bondinstructed_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> BondInstructedEventCallbackType<TExtensions>
where
    BondInstructedResult: Clone + 'static,
    F: for<'a> Fn(Vec<BondInstructedResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type BondInstructedEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<BondInstructedResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct BondInstructedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: BondInstructedEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> BondInstructedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        BondInstructedResult: Clone + 'static,
        F: for<'a> Fn(Vec<BondInstructedResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        Self {
            callback: bondinstructed_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,

                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for BondInstructedEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<BondInstructedResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data
                    .downcast::<BondInstructedData>()
                    .ok()
                    .map(|arc| BondInstructedResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("BondInstructedEvent: Unexpected data type - expected: BondInstructedData")
        }
    }
}

pub fn proposed_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> ProposedEventCallbackType<TExtensions>
where
    ProposedResult: Clone + 'static,
    F: for<'a> Fn(Vec<ProposedResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type ProposedEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<ProposedResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct ProposedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: ProposedEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> ProposedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        ProposedResult: Clone + 'static,
        F: for<'a> Fn(Vec<ProposedResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        Self {
            callback: proposed_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,

                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for ProposedEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<ProposedResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data
                    .downcast::<ProposedData>()
                    .ok()
                    .map(|arc| ProposedResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("ProposedEvent: Unexpected data type - expected: ProposedData")
        }
    }
}

pub fn proved_handler<TExtensions, F, Fut>(custom_logic: F) -> ProvedEventCallbackType<TExtensions>
where
    ProvedResult: Clone + 'static,
    F: for<'a> Fn(Vec<ProvedResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type ProvedEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<ProvedResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct ProvedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: ProvedEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> ProvedEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        ProvedResult: Clone + 'static,
        F: for<'a> Fn(Vec<ProvedResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        Self {
            callback: proved_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,

                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for ProvedEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<ProvedResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data
                    .downcast::<ProvedData>()
                    .ok()
                    .map(|arc| ProvedResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("ProvedEvent: Unexpected data type - expected: ProvedData")
        }
    }
}

pub enum ShastaInboxEventType<TExtensions>
where
    TExtensions: 'static + Send + Sync,
{
    BondInstructed(BondInstructedEvent<TExtensions>),
    Proposed(ProposedEvent<TExtensions>),
    Proved(ProvedEvent<TExtensions>),
}

pub async fn shasta_inbox_contract(
    network: &str,
) -> RindexerShastaInboxGenInstance<Arc<RindexerProvider>, AnyNetwork> {
    let address: Address = "0xae78736cd615f374d3085123a210448e74fc6393"
        .parse()
        .expect("Invalid address");
    RindexerShastaInboxGen::new(
        address,
        get_provider_cache_for_network(network)
            .await
            .get_inner_provider(),
    )
}

pub async fn decoder_contract(
    network: &str,
) -> RindexerShastaInboxGenInstance<Arc<RindexerProvider>, AnyNetwork> {
    if network == "local" {
        RindexerShastaInboxGen::new(
            // do not care about address here its decoding makes it easier to handle ValueOrArray
            Address::ZERO,
            get_provider_cache_for_network(network)
                .await
                .get_inner_provider(),
        )
    } else {
        panic!("Network not supported");
    }
}

impl<TExtensions> ShastaInboxEventType<TExtensions>
where
    TExtensions: 'static + Send + Sync,
{
    pub fn topic_id(&self) -> &'static str {
        match self {
            ShastaInboxEventType::BondInstructed(_) => {
                "0xf2d537d03425ffbe0a312cc4b640d80e634171d856a2e5b961d4f3c6cf20e1a7"
            }
            ShastaInboxEventType::Proposed(_) => {
                "0x10b2060c55406ea48522476f67fd813d4984b12078555d3e2a377e35839d7d01"
            }
            ShastaInboxEventType::Proved(_) => {
                "0xb2d5049ba96efb9e1fee66a51e4e6cbdfa2949627891ee29c6e4281abb8da03c"
            }
        }
    }

    pub fn event_name(&self) -> &'static str {
        match self {
            ShastaInboxEventType::BondInstructed(_) => "BondInstructed",
            ShastaInboxEventType::Proposed(_) => "Proposed",
            ShastaInboxEventType::Proved(_) => "Proved",
        }
    }

    pub fn contract_name(&self) -> String {
        "ShastaInbox".to_string()
    }

    async fn get_provider(&self, network: &str) -> Arc<JsonRpcCachedProvider> {
        get_provider_cache_for_network(network).await
    }

    fn decoder(
        &self,
        network: &str,
    ) -> Arc<dyn Fn(Vec<B256>, Bytes) -> Arc<dyn Any + Send + Sync> + Send + Sync> {
        let decoder_contract = decoder_contract(network);

        match self {
            ShastaInboxEventType::BondInstructed(_) => {
                Arc::new(move |topics: Vec<B256>, data: Bytes| {
                    match BondInstructedData::decode_raw_log(topics, &data[0..]) {
                        Ok(event) => {
                            let result: BondInstructedData = event;
                            Arc::new(result) as Arc<dyn Any + Send + Sync>
                        }
                        Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                    }
                })
            }

            ShastaInboxEventType::Proposed(_) => Arc::new(move |topics: Vec<B256>, data: Bytes| {
                match ProposedData::decode_raw_log(topics, &data[0..]) {
                    Ok(event) => {
                        let result: ProposedData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                }
            }),

            ShastaInboxEventType::Proved(_) => Arc::new(move |topics: Vec<B256>, data: Bytes| {
                match ProvedData::decode_raw_log(topics, &data[0..]) {
                    Ok(event) => {
                        let result: ProvedData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                }
            }),
        }
    }

    pub async fn register(self, manifest_path: &PathBuf, registry: &mut EventCallbackRegistry) {
        let rindexer_yaml = read_manifest(manifest_path).expect("Failed to read rindexer.yaml");
        let topic_id = self.topic_id();
        let contract_name = self.contract_name();
        let event_name = self.event_name();

        let contract_details = rindexer_yaml
            .all_contracts()
            .iter()
            .find(|c| c.name == contract_name)
            .unwrap_or_else(|| {
                panic!(
                    "Contract {} not found please make sure its defined in the rindexer.yaml",
                    contract_name
                )
            })
            .clone();

        let index_event_in_order = contract_details
            .index_event_in_order
            .as_ref()
            .map_or(false, |vec| vec.contains(&event_name.to_string()));

        // Expect providers to have been initialized, but it's an async init so this should
        // be fast but for correctness we must await each future.
        let mut providers = HashMap::new();
        for n in contract_details.details.iter() {
            let provider = self.get_provider(&n.network).await;
            providers.insert(n.network.clone(), provider);
        }

        let contract = ContractInformation {
            name: contract_details
                .before_modify_name_if_filter_readonly()
                .into_owned(),
            details: contract_details
                .details
                .iter()
                .map(|c| {
                    let provider = providers
                        .get(&c.network)
                        .expect("must have a provider")
                        .clone();

                    NetworkContract {
                        id: generate_random_id(10),
                        network: c.network.clone(),
                        cached_provider: provider.clone(),
                        block_clock: BlockClock::new(
                            rindexer_yaml.timestamps,
                            rindexer_yaml.config.timestamp_sample_rate,
                            provider.clone(),
                        ),
                        decoder: self.decoder(&c.network),
                        indexing_contract_setup: c.indexing_contract_setup(manifest_path),
                        start_block: c.start_block,
                        end_block: c.end_block,
                        disable_logs_bloom_checks: rindexer_yaml
                            .networks
                            .iter()
                            .find(|n| n.name == c.network)
                            .map_or(false, |n| n.disable_logs_bloom_checks.unwrap_or_default()),
                    }
                })
                .collect(),
            abi: contract_details.abi,
            reorg_safe_distance: contract_details.reorg_safe_distance.unwrap_or_default(),
        };

        let callback: Arc<
            dyn Fn(Vec<EventResult>) -> BoxFuture<'static, EventCallbackResult<()>> + Send + Sync,
        > = match self {
            ShastaInboxEventType::BondInstructed(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            ShastaInboxEventType::Proposed(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            ShastaInboxEventType::Proved(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }
        };

        registry.register_event(EventCallbackRegistryInformation {
            id: generate_random_id(10),
            indexer_name: "indexer".to_string(),
            event_name: event_name.to_string(),
            index_event_in_order,
            topic_id: topic_id.parse::<B256>().unwrap(),
            contract,
            callback,
        });
    }
}
