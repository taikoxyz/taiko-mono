// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { Test } from "forge-std/src/Test.sol";
import { IInbox } from "src/layer1/shasta/iface/IInbox.sol";
import { LibBlobs } from "src/layer1/shasta/libs/LibBlobs.sol";
import { LibProveDataDecoder } from "src/layer1/shasta/libs/LibProveDataDecoder.sol";

/// @title LibProveDataDecoderFuzz
/// @notice Fuzzy tests for LibProveDataDecoder to ensure encode/decode correctness
/// @custom:security-contact security@taiko.xyz
contract LibProveDataDecoderFuzz is Test {
    /// @notice Fuzz test for single proposal and claim
    function testFuzz_encodeDecodeSingleProposal(
        uint48 proposalId,
        address proposer,
        bool isForcedInclusion,
        uint8 basefeeSharingPctg,
        bytes32 proposalHash,
        address designatedProver,
        address actualProver
    )
        public
        pure
    {
        uint48 originTimestamp = 1000;
        uint48 originBlockNumber = 100;
        uint24 blobOffset = 512;
        uint48 blobTimestamp = 1001;
        bytes32 parentClaimHash = keccak256("parent");
        uint48 endBlockNumber = 200;
        bytes32 endBlockHash = keccak256("endBlock");
        bytes32 endStateRoot = keccak256("endState");
        bytes32[] memory blobHashes = new bytes32[](2);
        blobHashes[0] = keccak256("blob1");
        blobHashes[1] = keccak256("blob2");

        IInbox.Proposal[] memory proposals = new IInbox.Proposal[](1);
        proposals[0].id = proposalId;
        proposals[0].proposer = proposer;
        proposals[0].originTimestamp = originTimestamp;
        proposals[0].originBlockNumber = originBlockNumber;
        proposals[0].isForcedInclusion = isForcedInclusion;
        proposals[0].basefeeSharingPctg = basefeeSharingPctg;
        proposals[0].blobSlice.blobHashes = blobHashes;
        proposals[0].blobSlice.offset = blobOffset;
        proposals[0].blobSlice.timestamp = blobTimestamp;
        proposals[0].coreStateHash = keccak256("coreState");

        IInbox.Claim[] memory claims = new IInbox.Claim[](1);
        claims[0].proposalHash = proposalHash;
        claims[0].parentClaimHash = parentClaimHash;
        claims[0].endBlockNumber = endBlockNumber;
        claims[0].endBlockHash = endBlockHash;
        claims[0].endStateRoot = endStateRoot;
        claims[0].designatedProver = designatedProver;
        claims[0].actualProver = actualProver;

        // Encode and decode
        bytes memory encoded = LibProveDataDecoder.encode(proposals, claims);
        (IInbox.Proposal[] memory decodedProposals, IInbox.Claim[] memory decodedClaims) =
            LibProveDataDecoder.decode(encoded);

        // Verify proposals
        assertEq(decodedProposals.length, 1);
        assertEq(decodedProposals[0].id, proposalId);
        assertEq(decodedProposals[0].proposer, proposer);
        assertEq(decodedProposals[0].originTimestamp, originTimestamp);
        assertEq(decodedProposals[0].originBlockNumber, originBlockNumber);
        assertEq(decodedProposals[0].isForcedInclusion, isForcedInclusion);
        assertEq(decodedProposals[0].basefeeSharingPctg, basefeeSharingPctg);
        assertEq(decodedProposals[0].blobSlice.offset, blobOffset);
        assertEq(decodedProposals[0].blobSlice.timestamp, blobTimestamp);
        assertEq(decodedProposals[0].blobSlice.blobHashes.length, 2);

        // Verify claims
        assertEq(decodedClaims.length, 1);
        assertEq(decodedClaims[0].proposalHash, proposalHash);
        assertEq(decodedClaims[0].parentClaimHash, parentClaimHash);
        assertEq(decodedClaims[0].endBlockNumber, endBlockNumber);
        assertEq(decodedClaims[0].endBlockHash, endBlockHash);
        assertEq(decodedClaims[0].endStateRoot, endStateRoot);
        assertEq(decodedClaims[0].designatedProver, designatedProver);
        assertEq(decodedClaims[0].actualProver, actualProver);
    }

    /// @notice Fuzz test with variable array lengths
    function testFuzz_encodeDecodeVariableLengths(
        uint8 proposalCount,
        uint8 blobHashCount
    )
        public
        pure
    {
        // Bound the inputs to reasonable values
        proposalCount = uint8(bound(proposalCount, 1, 15));
        blobHashCount = uint8(bound(blobHashCount, 0, 8));

        // Create proposals
        IInbox.Proposal[] memory proposals = new IInbox.Proposal[](proposalCount);
        for (uint256 i = 0; i < proposalCount; i++) {
            bytes32[] memory blobHashes = new bytes32[](blobHashCount);
            for (uint256 j = 0; j < blobHashCount; j++) {
                blobHashes[j] = keccak256(abi.encodePacked("blob", i, j));
            }

            proposals[i] = IInbox.Proposal({
                id: uint48(i + 1),
                proposer: address(uint160(0x1000 + i)),
                originTimestamp: uint48(1_000_000 + i),
                originBlockNumber: uint48(5_000_000 + i),
                isForcedInclusion: i % 2 == 0,
                basefeeSharingPctg: uint8(50 + i),
                blobSlice: LibBlobs.BlobSlice({
                    blobHashes: blobHashes,
                    offset: uint24(1024 * i),
                    timestamp: uint48(1_000_001 + i)
                }),
                coreStateHash: keccak256(abi.encodePacked("state", i))
            });
        }

        // Create claims
        IInbox.Claim[] memory claims = new IInbox.Claim[](proposalCount);
        for (uint256 i = 0; i < proposalCount; i++) {
            claims[i] = IInbox.Claim({
                proposalHash: keccak256(abi.encodePacked("proposal", i)),
                parentClaimHash: keccak256(abi.encodePacked("parent", i)),
                endBlockNumber: uint48(2_000_000 + i),
                endBlockHash: keccak256(abi.encodePacked("endBlock", i)),
                endStateRoot: keccak256(abi.encodePacked("endState", i)),
                designatedProver: address(uint160(0x4000 + i)),
                actualProver: address(uint160(0x5000 + i))
            });
        }

        // Encode
        bytes memory encoded = LibProveDataDecoder.encode(proposals, claims);

        // Decode
        (IInbox.Proposal[] memory decodedProposals, IInbox.Claim[] memory decodedClaims) =
            LibProveDataDecoder.decode(encoded);

        // Verify basic properties
        assertEq(decodedProposals.length, proposalCount, "Proposals length mismatch");
        assertEq(decodedClaims.length, proposalCount, "Claims length mismatch");

        // Verify proposal details
        for (uint256 i = 0; i < proposalCount; i++) {
            assertEq(decodedProposals[i].id, proposals[i].id, "Proposal id mismatch");
            assertEq(decodedProposals[i].proposer, proposals[i].proposer, "Proposer mismatch");
            assertEq(
                decodedProposals[i].originTimestamp,
                proposals[i].originTimestamp,
                "Origin timestamp mismatch"
            );
            assertEq(
                decodedProposals[i].originBlockNumber,
                proposals[i].originBlockNumber,
                "Origin block number mismatch"
            );
            assertEq(
                decodedProposals[i].isForcedInclusion,
                proposals[i].isForcedInclusion,
                "Forced inclusion mismatch"
            );
            assertEq(
                decodedProposals[i].basefeeSharingPctg,
                proposals[i].basefeeSharingPctg,
                "Basefee sharing pctg mismatch"
            );
            assertEq(
                decodedProposals[i].coreStateHash,
                proposals[i].coreStateHash,
                "Core state hash mismatch"
            );

            assertEq(
                decodedProposals[i].blobSlice.blobHashes.length,
                blobHashCount,
                "Blob hash count mismatch"
            );
            assertEq(
                decodedProposals[i].blobSlice.offset,
                proposals[i].blobSlice.offset,
                "Blob offset mismatch"
            );
            assertEq(
                decodedProposals[i].blobSlice.timestamp,
                proposals[i].blobSlice.timestamp,
                "Blob timestamp mismatch"
            );

            for (uint256 j = 0; j < blobHashCount; j++) {
                assertEq(
                    decodedProposals[i].blobSlice.blobHashes[j],
                    proposals[i].blobSlice.blobHashes[j],
                    "Blob hash mismatch"
                );
            }

            // Verify claim details
            assertEq(
                decodedClaims[i].proposalHash,
                claims[i].proposalHash,
                "Claim proposal hash mismatch"
            );
            assertEq(
                decodedClaims[i].parentClaimHash,
                claims[i].parentClaimHash,
                "Parent claim hash mismatch"
            );
            assertEq(
                decodedClaims[i].endBlockNumber,
                claims[i].endBlockNumber,
                "End block number mismatch"
            );
            assertEq(
                decodedClaims[i].endBlockHash, claims[i].endBlockHash, "End block hash mismatch"
            );
            assertEq(
                decodedClaims[i].endStateRoot, claims[i].endStateRoot, "End state root mismatch"
            );
            assertEq(
                decodedClaims[i].designatedProver,
                claims[i].designatedProver,
                "Designated prover mismatch"
            );
            assertEq(
                decodedClaims[i].actualProver, claims[i].actualProver, "Actual prover mismatch"
            );
        }
    }

    /// @notice Fuzz test to ensure encoded size is always smaller than abi.encode
    function testFuzz_encodedSizeComparison(uint8 proposalCount, uint8 blobHashCount) public pure {
        // Bound the inputs
        proposalCount = uint8(bound(proposalCount, 1, 10));
        blobHashCount = uint8(bound(blobHashCount, 1, 5));

        // Create test data
        (IInbox.Proposal[] memory proposals, IInbox.Claim[] memory claims) =
            _createTestData(proposalCount, blobHashCount);

        // Encode with both methods
        bytes memory abiEncoded = abi.encode(proposals, claims);
        bytes memory libEncoded = LibProveDataDecoder.encode(proposals, claims);

        // Verify LibProveDataDecoder produces smaller output
        assertLt(
            libEncoded.length,
            abiEncoded.length,
            "LibProveDataDecoder should produce smaller output"
        );

        // Verify decode produces identical results
        (IInbox.Proposal[] memory decodedProposals, IInbox.Claim[] memory decodedClaims) =
            LibProveDataDecoder.decode(libEncoded);

        assertEq(decodedProposals.length, proposals.length, "Proposals length mismatch");
        assertEq(decodedClaims.length, claims.length, "Claims length mismatch");

        // Verify first and last elements to ensure correctness
        if (proposals.length > 0) {
            assertEq(decodedProposals[0].id, proposals[0].id, "First proposal id mismatch");
            assertEq(
                decodedProposals[proposals.length - 1].id,
                proposals[proposals.length - 1].id,
                "Last proposal id mismatch"
            );
            assertEq(
                decodedClaims[0].proposalHash, claims[0].proposalHash, "First claim hash mismatch"
            );
            assertEq(
                decodedClaims[claims.length - 1].proposalHash,
                claims[claims.length - 1].proposalHash,
                "Last claim hash mismatch"
            );
        }
    }

    /// @notice Fuzz test for edge case values
    function testFuzz_edgeCaseValues(
        bool useMaxValues,
        bool useMinValues,
        uint8 arrayLength
    )
        public
        pure
    {
        arrayLength = uint8(bound(arrayLength, 1, 5));

        IInbox.Proposal[] memory proposals = new IInbox.Proposal[](arrayLength);
        IInbox.Claim[] memory claims = new IInbox.Claim[](arrayLength);

        for (uint256 i = 0; i < arrayLength; i++) {
            // Use extreme values based on flags
            uint48 id = useMaxValues ? type(uint48).max : (useMinValues ? 0 : uint48(i + 1));
            address proposer = useMaxValues
                ? address(type(uint160).max)
                : (useMinValues ? address(0) : address(uint160(0x1000 + i)));
            uint48 timestamp =
                useMaxValues ? type(uint48).max : (useMinValues ? 0 : uint48(1_000_000 + i));
            uint8 basefeeSharingPctg =
                useMaxValues ? type(uint8).max : (useMinValues ? 0 : uint8(50 + i));

            bytes32[] memory blobHashes = new bytes32[](useMaxValues ? 5 : (useMinValues ? 0 : 2));
            for (uint256 j = 0; j < blobHashes.length; j++) {
                blobHashes[j] = useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("blob", i, j)));
            }

            proposals[i] = IInbox.Proposal({
                id: id,
                proposer: proposer,
                originTimestamp: timestamp,
                originBlockNumber: timestamp,
                isForcedInclusion: useMaxValues ? true : (useMinValues ? false : i % 2 == 0),
                basefeeSharingPctg: basefeeSharingPctg,
                blobSlice: LibBlobs.BlobSlice({
                    blobHashes: blobHashes,
                    offset: useMaxValues ? type(uint24).max : (useMinValues ? 0 : uint24(1024 * i)),
                    timestamp: timestamp
                }),
                coreStateHash: useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("state", i)))
            });

            claims[i] = IInbox.Claim({
                proposalHash: useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("proposal", i))),
                parentClaimHash: useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("parent", i))),
                endBlockNumber: useMaxValues
                    ? type(uint48).max
                    : (useMinValues ? 0 : uint48(2_000_000 + i)),
                endBlockHash: useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("endBlock", i))),
                endStateRoot: useMaxValues
                    ? bytes32(type(uint256).max)
                    : (useMinValues ? bytes32(0) : keccak256(abi.encodePacked("endState", i))),
                designatedProver: useMaxValues
                    ? address(type(uint160).max)
                    : (useMinValues ? address(0) : address(uint160(0x4000 + i))),
                actualProver: useMaxValues
                    ? address(type(uint160).max)
                    : (useMinValues ? address(0) : address(uint160(0x5000 + i)))
            });
        }

        // Encode and decode
        bytes memory encoded = LibProveDataDecoder.encode(proposals, claims);
        (IInbox.Proposal[] memory decodedProposals, IInbox.Claim[] memory decodedClaims) =
            LibProveDataDecoder.decode(encoded);

        // Verify all values are preserved
        assertEq(decodedProposals.length, arrayLength);
        assertEq(decodedClaims.length, arrayLength);

        for (uint256 i = 0; i < arrayLength; i++) {
            assertEq(decodedProposals[i].id, proposals[i].id);
            assertEq(decodedProposals[i].proposer, proposals[i].proposer);
            assertEq(decodedProposals[i].basefeeSharingPctg, proposals[i].basefeeSharingPctg);
            assertEq(decodedClaims[i].proposalHash, claims[i].proposalHash);
            assertEq(decodedClaims[i].endBlockNumber, claims[i].endBlockNumber);
        }
    }

    /// @notice Helper function to create test data
    function _createTestData(
        uint256 _proposalCount,
        uint256 _blobHashCount
    )
        private
        pure
        returns (IInbox.Proposal[] memory proposals, IInbox.Claim[] memory claims)
    {
        proposals = new IInbox.Proposal[](_proposalCount);
        for (uint256 i = 0; i < _proposalCount; i++) {
            bytes32[] memory blobHashes = new bytes32[](_blobHashCount);
            for (uint256 j = 0; j < _blobHashCount; j++) {
                blobHashes[j] = keccak256(abi.encodePacked("blob", i, j));
            }

            proposals[i] = IInbox.Proposal({
                id: uint48(96 + i),
                proposer: address(uint160(0x1000 + i)),
                originTimestamp: uint48(1_000_000 + i * 10),
                originBlockNumber: uint48(5_000_000 + i * 10),
                isForcedInclusion: i % 2 == 0,
                basefeeSharingPctg: uint8(50 + i * 10),
                blobSlice: LibBlobs.BlobSlice({
                    blobHashes: blobHashes,
                    offset: uint24(1024 * (i + 1)),
                    timestamp: uint48(1_000_001 + i * 10)
                }),
                coreStateHash: keccak256(abi.encodePacked("core_state", i))
            });
        }

        claims = new IInbox.Claim[](_proposalCount);
        for (uint256 i = 0; i < _proposalCount; i++) {
            claims[i] = IInbox.Claim({
                proposalHash: keccak256(abi.encodePacked("proposal", i)),
                parentClaimHash: keccak256(abi.encodePacked("parent_claim", i)),
                endBlockNumber: uint48(2_000_000 + i * 10),
                endBlockHash: keccak256(abi.encodePacked("end_block", i)),
                endStateRoot: keccak256(abi.encodePacked("end_state", i)),
                designatedProver: address(uint160(0x2000 + i)),
                actualProver: address(uint160(0x3000 + i))
            });
        }
    }
}
