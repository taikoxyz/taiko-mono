---
title: Based Preconfirmations
description: Core concept page for "Based Preconfirmations".
---

Taiko Alethia is implementing based preconfirmations to enhance transaction finality, reducing the current 12-second block time to potentially sub-second finality. This significantly improves UX, particularly for applications requiring fast transaction execution. Based preconfirmations allow transactions to receive early inclusion guarantees from preconfirmers, providing users with immediate execution assurance.

## What Are Based Preconfirmations?

A preconfirmation (preconf) is a cryptographic commitment from a preconfer that a transaction will be included into a block. A preconfer will sequence blocks offchain, and gossip them to other nodes, and the nodes will treat them as canonical blocks. At the end of their turn to preconf, they will propose them onchain to Layer 1, exactly as a typical non-preconfed block would be proposed.

To achieve this, there is a two-stage rollout of how this will operate.

### Stage 1

The three companies providing solutions will each run a preconfer, and be whitelisted in the protocol onchain.

These entities are Nethermind, Chainbound, and Gattaca. From day one we will achieve client diversity.

Each entity will operate their own custom solution that adheres to the onchain protocol and offchain spec, allowing us to focus on delivering fast, reliable preconfirmations.

### Stage 2

L1 validators will opt in to being a preconfer, and either run their own preconfer, or delegate their preconfing rights to a separate entity running one of the above solutions.

Rolling out in two distinct stages lets us not only test the softwares without potential bugs impacting validators, but lets us find the ideal configurable parameters, such as block time, that provide the ideal mix of profitability and user experience.

## Execution vs. Inclusion Preconfirmations

There are two primary types of preconfirmations:

- **Inclusion Preconfirmations**:

  - Guarantees that the transaction will be eventually included in L1.
  - No strict guarantee on when it will execute or in what order.
  - Often used in systems that rely on external MEV solutions.
<br/>
- **Execution Preconfirmations**:

  - Ensures a transaction's exact execution ordering and state before L1 inclusion.
  - Provides a stronger guarantee for applications like DeFi, high-frequency trading, and gaming.
  - Transactions are executed immediately in L2 based on the preconfirmed state.

Execution preconfirmations remove uncertainty, making applications feel as responsive as centralized systems while preserving Ethereum's security model.

## Taiko's Preconfirmation Implementation

Taiko has three independant preconfirmation solutions that all offer execution preconfirmations - that is to say, they provide block-based preconfirmations, not transaction based.

There is also no centralized gateway or service, the preconfirmation solutions run alongside a regular Taiko node as a sidecar.

This means that the preconfirmers read transactions from the mempool, just like Ethereum itself.

The path a preconfirmation takes from send -> receive receipt?

User sends a transaction to the same RPC they do now, no changes are necessary at all for the user. The transaction enters the mempool, and a preconfirmer fetches transactions, and creates a block. They then gossip this block to the other nodes on the network, but do *not* propose it to the TaikoInbox contracto n L1 yet.

We term this "sequencing" - when a preconfirmer is creating ang gossiping blocks, but they are not proposed on L1 yet. A user receives a receipt, and all nodes state is updated, when a block is sequenced. Blocks can be sequenced on top of other sequenced blocks.

Thus, a preconfirmer can sequence hundreds of blocks, before proposing them onchain in what we call a "batch". A batch is a group of blocks that share common characteristics that can be reused, such as who the preconfirmer is, and the L1 block used for anchoring.

Each preconfirmer gets a 32 slot epoch in which to sequence and propose. It is up to the preconfirmer to determine when to propose their sequenced blocks on chain. This will be completely irrelevant to the end-user - they will have had their transaction receipt for long already, as soon as the block was sequenced. Proposing onchain just confirms that sequenced state, keeping us based.

Block time on Taiko Alethia thus becomes configurable - if a preconfirmer chooses to set their target block time to 500ms, we could see 500-600ms transaction executions. However, if a preconfirmer determines that blocks made at this speed are not profitable to both propose onchain and prove, they can raise (or lower) the target block time.

This will create the best possible mix of profitability and user experience for L1 validators, preconfirmers, and users.

The preconfirmation process follows seven key steps:

1. **Registration**

    L1 validators opt-in to become preconfirmers by staking collateral and registering with the PreconfServiceManager contract, which interacts with EigenLayer middleware.

2. **Election**

    A single preconfer is elected from the registered validators for each slot. If the current proposer is registered as a preconfer, they will be chosen. Otherwise, the next preconfer in the lookahead will provide preconfirmations.

3. **Request Submission**

    Users submit transactions to the Taiko public mempool. Transactions with higher L2 priority fees have a better chance of being preconfirmed, as the fee goes to the preconfer.

4. **Preconfirmation Publication**

    The elected preconfer collects transactions from the L2 mempool, builds an L2 block, and propagates this block to the Taiko network. This propagation serves as the preconfirmation.

5. **State Sync**

    Taiko full nodes verify the preconfirmed block's signature, execute the L2 transactions, and provide users with the latest preconfirmed state without waiting for L1 inclusion.

6. **L1 Inclusion**

    The preconfirmer must submit preconfirmed L2 blocks to the L1 Taiko inbox contract. This is done either through forced inclusion lists in MEV-Boost (if the preconfer is the current slot's proposer) or via the L1 mempool.

7. **Slashing**

    If a preconfer fails to honor their commitments—either by not including preconfirmed transactions or by submitting an incorrect lookahead—they face slashing penalties, which are enforced through the EigenLayer slashing mechanism.

## Benefits of Based Preconfirmations

- **Faster Transaction Finality**: Preconfirmations enable transactions to be confirmed as fast as the configured block time, which could be realistically between 500ms to 2seconds, depending on the solution and configuration options.

- **Stronger Economic Security**: Preconfirmers stake collateralized ETH and face slashing penalties for dishonesty, reducing reliance on centralized sequencers while maintaining Ethereum's security guarantees.

- **Censorship Resistance & Trust-Minimization**: Based preconfirmations leverage Ethereum validators to sequence transactions, ensuring decentralized sequencing with resistance to censorship by MEV players.

 - With the addition of the `ForcedInclusionStore` smart contract which allows users to submit transactions and force their inclusion irregardless of the preconfers, the protocol can remain censorship-resistant even while preconfers are permissioned.

## Summary

Based preconfirmations enable much faster transaction finality by allowing Ethereum L1 validators to issue cryptographic guarantees on transaction inclusion and execution before block finalization. Transactions are prioritized based on execution preconfirmations (strict order + execution guarantee) or inclusion preconfirmations (eventual inclusion with flexible execution). Preconfirmers stake collateral, ensuring economic security via forced inclusion and slashing penalties for misbehavior.
